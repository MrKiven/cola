extern crate rustc_serialize as serialize;

use serialize::base64::{self, ToBase64};
use serialize::hex::FromHex;

fn main() {
    let input = "2d2d2d2d2d424547494e2043455254494649434154452d2d2d2d2d0a4d49494467444343416d6967417749424167494645466d44645949774451594a4b6f5a496876634e41514546425141774954454c4d416b474131554542684d430a51303478456a415142674e5642416f5443554e475130456754304e424d544165467730784e6a45774d6a51774e7a497a4d6a5261467730794d5445774d6a51770a4e7a497a4d6a52614d484578437a414a42674e5642415954416b4e4f4d524977454159445651514b45776c44526b4e424945394451544578447a414e42674e560a42417354426b4a6862325a76627a455a4d4263474131554543784d5154334a6e59573570656d463061573975595777744d5445694d434147413155454177775a0a516d46765a6d3976514f57756e6553376d4542614e6a67344d546b354f546c414d5443426e7a414e42676b71686b6947397730424151454641414f426a5141770a67596b4367594541333062674341593661677a754a6363534b664c652f324e654f65556d32475a4675616a6169364342394530534f673651796d577547772f660a58794c3672635a642f6561766577314563324544546571344467567564616836485a624933455874325453784c706e364177444d774b675347685770785232560a31486e45694979544f436a6457653567554a6c3632556e4535616345726a4f304739772b6f2b714779313372302f5a5a366830434177454141614f42386a43420a377a416642674e5648534d454744415767425452322b6d4967755864476f394d7167434d766e7a79717876323254424942674e56485341455154412f4d4430470a43474342484962764b6745424d4445774c7759494b775942425155484167455749326830644841364c7939336433637559325a6a5953356a62323075593234760a64584d7664584d744d545175614852744d44634741315564487751774d4334774c4b41716f4369474a6d6830644841364c79396a636d777559325a6a5953356a0a6232307559323476556c4e424c324e79624451304d44457559334a734d4173474131556444775145417749443644416442674e564851344546675155527174300a715264436b526562707556416d6b69446c4d516a39354977485159445652306c42425977464159494b7759424251554841774947434373474151554642774d450a4d41304743537147534962334451454242515541413449424151414854676b5167343770344679355043466364477a58354c6e487179484b2f6379736a63706f0a6c48536a38392f732f6b5831705855374a7167702f464431524a752f4e6736726d6748534e4452395a4877617064632b2b5052537844424e2f2b32426e52364a0a34436f784862306537736a446464623752316365547552584e6a5a7572755638306a35484679636772485373534c492f4c655a71317570304e4c4d2b594f78740a2f2b7a736e6b416947664c76524356546c707077676668707354314c6864567672446b594d656462677241317a714c2f6b6258653044496462386b6e324738510a377a523853455950586e57734452324b746e6f35336d784b6878396b673344516179574d75644e593871792b536f30754254314371437357523753576f4d70580a56536e4b4c5857424352447165765674344232667054486f6f34754d346f5a44676759616631346b79393064306c57480a2d2d2d2d2d454e442043455254494649434154452d2d2d2d2d0a";
    let result1 = input.from_hex().unwrap().to_base64(base64::STANDARD);
    let result = hex_to_base64(input);

    println!("result : {}", result);
    println!("result1: {}", result1);
    assert_eq!(result, result1);
}

fn hex_to_bytes(hex_string: &str) -> Vec<u8> {
    let input_chars: Vec<_> = hex_string.chars().collect();

    input_chars.chunks(2).map(|chunk| {
            let first_byte = chunk[0].to_digit(16).unwrap();
            let second_byte = chunk[1].to_digit(16).unwrap();
            ((first_byte << 4) | second_byte) as u8 }).collect()
}

/// Encode the decoded bytes into Base64
fn bytes_to_base64(decoded_bytes: &[u8]) -> String {
    let mut output = String::new();
    let alphabet: Vec<_> =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".chars().collect();

    for chunk in decoded_bytes.chunks(3) {
        let c0 = chunk[0];
        let b = (c0 & 0xFC) >> 2;
        output.push(alphabet[b as usize]);

        let mut b = (c0 & 0x03) << 4;

        if let Some(c1) = chunk.get(1) {
            b |= (c1 & 0xF0) >> 4;
            output.push(alphabet[b as usize]);

            let mut b = (c1 & 0x0F) << 2;

            if let Some(c2) = chunk.get(2) {
                b |= (c2 & 0xC0) >> 6;
                output.push(alphabet[b as usize]);

                let b = c2 & 0x3F;
                output.push(alphabet[b as usize]);
            } else {
                output.push(alphabet[b as usize]);
                output.push('=');
            }
        } else {
            output.push(alphabet[b as usize]);
            output.push_str("==");
        }
    }

    output
}

fn hex_to_base64(hex_string: &str) -> String {
    bytes_to_base64(&hex_to_bytes(hex_string))
}

#[test]
fn test_hex_to_base64() {
    assert_eq!(
        hex_to_base64("49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d"),
        "SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t"
    );
}
